<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Synthesis Offline Tree Viewer</title>
<style>
  :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9aa4af; --panel:#111826; --accent:#4aa3ff; }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:var(--bg);color:var(--fg);}
  header{display:flex;align-items:center;gap:12px;padding:10px 12px;background:#0d1522;border-bottom:1px solid #1f2a37;position:sticky;top:0;z-index:10;}
  #hamb{font-size:18px;background:transparent;border:1px solid #2b3645;color:var(--fg);border-radius:10px;padding:6px 10px;cursor:pointer;}
  #title{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
  #search{flex:1;min-width:140px;background:#0b1220;border:1px solid #2b3645;border-radius:10px;padding:8px 10px;color:var(--fg);}
  #level{width:70px;background:#0b1220;border:1px solid #2b3645;border-radius:10px;padding:8px 10px;color:var(--fg);}
  #actions button{background:#0b1220;border:1px solid #2b3645;color:var(--fg);border-radius:10px;padding:8px 10px;cursor:pointer;}
  #wrap{display:grid;grid-template-columns:320px 1fr;min-height:calc(100vh - 54px);}
  #sidebar{background:var(--panel);border-right:1px solid #1f2a37;overflow:auto;}
  #sidebar.hidden{display:none;}
  #treeList{list-style:none;margin:0;padding:8px;}
  #treeList li{padding:8px 10px;border-radius:10px;cursor:pointer;color:var(--fg);}
  #treeList li:hover{background:#0b1220;}
  #treeList li.active{outline:1px solid #2b3645;background:#0b1220;}
  #main{overflow:auto;padding:12px;}
  .muted{color:var(--muted);}
  .node{margin-left:12px;border-left:1px dashed #2b3645;padding-left:10px;}
  details{border-radius:10px;padding:4px 6px;}
  details summary{cursor:pointer;list-style:none;}
  details summary::-webkit-details-marker{display:none;}
  .lbl{font-weight:600;}
  .sym{color:#c7d2fe;margin-left:6px;}
  .doc{margin:6px 0 10px 0;color:var(--muted);font-size:13px;line-height:1.35;}
  .tag{display:inline-block;margin-left:8px;font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #2b3645;color:var(--muted);}
  .hiddenNode{display:none;}
  .hit{outline:2px solid var(--accent);outline-offset:2px;border-radius:10px;}
  .palette{display:none;position:fixed;right:14px;bottom:14px;background:#0b1220;border:1px solid #2b3645;border-radius:14px;padding:10px;max-width:320px;}
  .palette.show{display:block;}
  .swatch{display:inline-block;width:18px;height:18px;border-radius:6px;margin:4px;border:1px solid #2b3645;cursor:pointer;}
  .swatch[data-c="red"]{background:#ef4444;}
  .swatch[data-c="orange"]{background:#f97316;}
  .swatch[data-c="yellow"]{background:#eab308;}
  .swatch[data-c="green"]{background:#22c55e;}
  .swatch[data-c="blue"]{background:#3b82f6;}
  .swatch[data-c="purple"]{background:#a855f7;}
  .swatch[data-c="gray"]{background:#94a3b8;}
  .legend{font-size:12px;color:var(--muted);margin-top:8px;line-height:1.35;}
</style>
</head>
<body>
<header>
  <button id="hamb" title="Toggle sidebar">☰</button>
  <div id="title">Synthesis Offline Tree Viewer</div>
  <input id="search" placeholder="Search labels / symbols / docs… (press Enter)"/>
  <input id="level" type="number" min="0" max="50" value="3" title="Expand/collapse depth (n levels)"/>
  <div id="actions">
    <button id="expandN">Expand n</button>
    <button id="collapseAll">Collapse all</button>
    <button id="showAll">Show all nodes</button>
  </div>
</header>

<div id="wrap">
  <aside id="sidebar">
    <div style="padding:10px 12px;border-bottom:1px solid #1f2a37;">
      <div style="font-weight:600;">Trees</div>
      <div class="muted" style="font-size:12px;margin-top:4px;">Click a tree. Shift‑click a node to exclude/include. Alt‑click to color‑label.</div>
    </div>
    <ul id="treeList"></ul>
  </aside>
  <main id="main">
    <div class="muted">Pick a tree on the left. This viewer is offline (no d3/CDN), so it should always render.</div>
    <div id="tree"></div>
  </main>
</div>

<div id="palette" class="palette">
  <div style="font-weight:600;margin-bottom:6px;">Label color</div>
  <div id="swatches"></div>
  <div style="margin-top:8px;">
    <input id="tagText" placeholder="Optional tag text…" style="width:100%;background:#0b1220;border:1px solid #2b3645;border-radius:10px;padding:8px 10px;color:var(--fg);"/>
  </div>
  <div class="legend">
    Alt‑click a node to open this palette.<br/>
    Shift‑click a node to exclude/include it.<br/>
    Labels persist in your browser (localStorage) per tree.
  </div>
</div>

<script>
const CATALOG_PATH = "enriched/trees_catalog.json";
let catalog = null;
let currentTreeId = null;
let currentTreeData = null;
let pendingLabelNodeId = null;

const $ = (sel) => document.querySelector(sel);
const treeEl = $("#tree");
const titleEl = $("#title");
const sidebar = $("#sidebar");
const listEl = $("#treeList");
const palette = $("#palette");
const swatchesEl = $("#swatches");
const tagTextEl = $("#tagText");

const COLORS = ["red","orange","yellow","green","blue","purple","gray"];

function lsKey(treeId){ return "synth_labels::" + treeId; }
function loadLabels(treeId){
  try { return JSON.parse(localStorage.getItem(lsKey(treeId)) || "{}"); } catch { return {}; }
}
function saveLabels(treeId, labels){
  localStorage.setItem(lsKey(treeId), JSON.stringify(labels));
}
function getNodeId(node){
  return node.id || node._id || node.path || node.label || Math.random().toString(36).slice(2);
}

function setDetailsOpenToDepth(rootDetails, depth){
  // depth 0: collapse all
  const all = rootDetails.querySelectorAll("details");
  all.forEach(d => d.open = false);
  if (depth <= 0) return;
  // open details up to depth
  const walk = (details, d) => {
    if (!details) return;
    if (d < depth) details.open = true;
    const kids = details.querySelectorAll(":scope > .node > details");
    kids.forEach(k => walk(k, d+1));
  };
  // the first details inside root container
  const first = rootDetails.querySelector("details");
  if (first) walk(first, 0);
}

function applyNodeLabelStyles(el, labels, nodeId){
  const info = labels[nodeId];
  if (!info) return;
  if (info.excluded) el.classList.add("hiddenNode");
  if (info.color){
    el.style.borderLeftColor = info.color;
    el.style.borderLeftWidth = "4px";
    el.style.borderLeftStyle = "solid";
  }
}

function renderNode(node, labels, depth=0){
  const nodeId = getNodeId(node);
  const container = document.createElement("div");
  container.className = "node";
  container.dataset.nodeId = nodeId;

  const kids = (node.children || []);
  const hasKids = kids.length > 0;

  const details = document.createElement("details");
  details.open = depth < 2;

  const summary = document.createElement("summary");
  const lbl = document.createElement("span");
  lbl.className = "lbl";
  lbl.textContent = node.label || node.name || nodeId;

  const sym = document.createElement("span");
  sym.className = "sym";
  sym.textContent = node.symbol ? (" " + node.symbol) : "";

  const type = document.createElement("span");
  type.className = "tag";
  type.textContent = node.type || (hasKids ? "group" : "leaf");

  summary.appendChild(lbl);
  if (node.symbol) summary.appendChild(sym);
  summary.appendChild(type);

  summary.addEventListener("click", (ev) => {
    // shift-click excludes/includes
    if (ev.shiftKey){
      ev.preventDefault();
      const labels = loadLabels(currentTreeId);
      labels[nodeId] = labels[nodeId] || {};
      labels[nodeId].excluded = !labels[nodeId].excluded;
      saveLabels(currentTreeId, labels);
      loadTree(currentTreeId); // re-render
    }
    // alt-click opens palette
    if (ev.altKey){
      ev.preventDefault();
      pendingLabelNodeId = nodeId;
      tagTextEl.value = (loadLabels(currentTreeId)[nodeId]?.tag || "");
      palette.classList.add("show");
    }
  });

  details.appendChild(summary);

  if (node.doc){
    const doc = document.createElement("div");
    doc.className = "doc";
    doc.textContent = node.doc;
    details.appendChild(doc);
  }

  if (hasKids){
    kids.forEach(ch => details.appendChild(renderNode(ch, labels, depth+1)));
  } else {
    const leafNote = document.createElement("div");
    leafNote.className = "doc";
    leafNote.textContent = "Leaf node.";
    details.appendChild(leafNote);
  }

  container.appendChild(details);

  applyNodeLabelStyles(container, labels, nodeId);
  // add tag chip if present
  const info = labels[nodeId];
  if (info && info.tag){
    const t = document.createElement("span");
    t.className = "tag";
    t.textContent = info.tag;
    summary.appendChild(t);
  }
  return container;
}

function indexText(node, buf){
  const parts = [node.label, node.name, node.symbol, node.doc, node.type].filter(Boolean).join(" ").toLowerCase();
  buf.push({ id: getNodeId(node), text: parts });
  (node.children || []).forEach(ch => indexText(ch, buf));
}

function highlightSearch(q){
  // naive: highlight containers whose summary text includes q
  treeEl.querySelectorAll(".hit").forEach(el => el.classList.remove("hit"));
  if (!q) return;
  const lower = q.toLowerCase();
  const nodes = treeEl.querySelectorAll(".node");
  nodes.forEach(n => {
    const txt = n.textContent.toLowerCase();
    if (txt.includes(lower)) n.classList.add("hit");
  });
}

async function loadCatalog(){
  const res = await fetch(CATALOG_PATH);
  catalog = await res.json();
  listEl.innerHTML = "";
  catalog.trees.forEach(t => {
    const li = document.createElement("li");
    li.textContent = t.title || t.id;
    li.dataset.treeId = t.id;
    li.addEventListener("click", () => loadTree(t.id));
    listEl.appendChild(li);
  });
}

async function loadTree(treeId){
  currentTreeId = treeId;
  // active highlight
  listEl.querySelectorAll("li").forEach(li => li.classList.toggle("active", li.dataset.treeId === treeId));
  const meta = catalog.trees.find(t => t.id === treeId);
  titleEl.textContent = meta?.title || treeId;

  const res = await fetch(meta.enriched_json);
  const data = await res.json();
  currentTreeData = data.root || data;

  const labels = loadLabels(treeId);

  treeEl.innerHTML = "";
  treeEl.appendChild(renderNode(currentTreeData, labels, 0));

  // apply initial depth
  setDetailsOpenToDepth(treeEl, parseInt($("#level").value || "3", 10));
}

function initPalette(){
  swatchesEl.innerHTML = "";
  COLORS.forEach(c => {
    const sw = document.createElement("span");
    sw.className = "swatch";
    sw.dataset.c = c;
    sw.addEventListener("click", () => {
      if (!pendingLabelNodeId) return;
      const labels = loadLabels(currentTreeId);
      labels[pendingLabelNodeId] = labels[pendingLabelNodeId] || {};
      labels[pendingLabelNodeId].color = c;
      const tag = (tagTextEl.value || "").trim();
      labels[pendingLabelNodeId].tag = tag || undefined;
      saveLabels(currentTreeId, labels);
      palette.classList.remove("show");
      pendingLabelNodeId = null;
      loadTree(currentTreeId);
    });
    swatchesEl.appendChild(sw);
  });
  // click outside to close
  document.addEventListener("click", (ev) => {
    if (palette.classList.contains("show") && !palette.contains(ev.target) && !(ev.target.closest("summary") && ev.altKey)) {
      palette.classList.remove("show");
      pendingLabelNodeId = null;
    }
  });
}

$("#hamb").addEventListener("click", () => sidebar.classList.toggle("hidden"));
$("#expandN").addEventListener("click", () => setDetailsOpenToDepth(treeEl, parseInt($("#level").value || "3", 10)));
$("#collapseAll").addEventListener("click", () => setDetailsOpenToDepth(treeEl, 0));
$("#showAll").addEventListener("click", () => {
  const labels = loadLabels(currentTreeId);
  Object.keys(labels).forEach(k => labels[k].excluded = false);
  saveLabels(currentTreeId, labels);
  loadTree(currentTreeId);
});
$("#search").addEventListener("keydown", (ev) => {
  if (ev.key === "Enter") highlightSearch($("#search").value.trim());
});

(async function(){
  initPalette();
  await loadCatalog();
  if (catalog.trees && catalog.trees.length) loadTree(catalog.trees[0].id);
})();
</script>
</body>
</html>
